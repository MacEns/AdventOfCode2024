@page "/day17"
@inject IWebHostEnvironment WebHostEnvironment

<PageTitle>Day @DayNumber</PageTitle>

<div class="container-fluid">
    <div class="d-flex justify-content-between">
        <h1>Day @DayNumber</h1>

        <div class="d-flex justify-content-around gap-4 flex-grow-1">
            <h4 class="border border-primary p-1">Part1 Result: @Part1Result</h4>
            <h4 class="border border-primary p-1">Part2 Result: @Part2Result</h4>
        </div>

        <div class="d-flex justify-content-end gap-2">
            <button class="btn btn-primary" @onclick="Part1">Part 1</button>
            <button class="btn btn-primary" @onclick="Part2" >Part 2</button>
        </div>
    </div>

    <div style="font-family: Consolas; ">

        <p class="my-0">Register A: @RegisterA</p>
        <p class="my-0">Register B: @RegisterB</p>
        <p class="my-0">Register C: @RegisterC</p>
        <br/>

        <p class="my-0">InstructionPointer: @InstructionPointer</p>
        <p class="my-0">Instructions:
            <span>
                @foreach (var (i, instruction) in Instructions.Index())
                {
                    var cssClass = i == InstructionPointer ? "fw-bold text-danger" : string.Empty;
                    var text = i == 0 ? instruction.ToString() : $", {instruction}";
                    <span class="@cssClass">@text</span>
                }
            </span>
        </p>
        <br/>

        <p class="my-0">ProgramOutput: @ProgramOutput</p>
    </div>
</div>

@code {
    private const int DayNumber = 17;

    private long Part1Result { get; set; } = 0;
    private long Part2Result { get; set; } = 0;

    private List<string> Input = new();

    private int InstructionPointer = 0;
    private long RegisterA = 0;
    private long RegisterB = 0;
    private long RegisterC = 0;
    private List<int> Instructions = new();
    private string ProgramOutput = string.Empty;

    protected override void OnInitialized()
    {
        try
        {
            var filePath = Path.Combine(WebHostEnvironment.WebRootPath, $"day{DayNumber}.txt");
            var file = File.ReadAllText(filePath);
            Input =  file
                .Split("\n")
                .Where(x => !string.IsNullOrWhiteSpace(x))
                .ToList();
            ParseInput();
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
        }
    }

    private void ParseInput()
    {
        InstructionPointer = 0;
        ProgramOutput = string.Empty;
        RegisterA = long.Parse(Input.FirstOrDefault(x => x.StartsWith("Register A:")).Split(" ").LastOrDefault());
        RegisterB = long.Parse(Input.FirstOrDefault(x => x.StartsWith("Register B:")).Split(" ").LastOrDefault());
        RegisterC = long.Parse(Input.FirstOrDefault(x => x.StartsWith("Register C:")).Split(" ").LastOrDefault());
        Instructions = Input.FirstOrDefault(x => x.StartsWith("Program:"))
            .Split(" ")
            .LastOrDefault()
            .Trim()
            .Split(',')
            .Select(int.Parse)
            .ToList();
    }

    private void Part1()
    {
        ParseInput();
    }

    private void Part2()
    {
        ParseInput();
    }

    private async Task GetOperation(int opCode)
    {
        var operation = opCode switch
        {
            0 => Adv(Instructions[InstructionPointer + 1]),
            1 => Bxl(Instructions[InstructionPointer + 1]),
            2 => Bst(Instructions[InstructionPointer + 1]),
            3 => Jnz(Instructions[InstructionPointer + 1]),
            4 => Bxc(Instructions[InstructionPointer + 1]),
            5 => Out(Instructions[InstructionPointer + 1]),
            6 => Bdv(Instructions[InstructionPointer + 1]),
            7 => Cdv(Instructions[InstructionPointer + 1]),
            _ => Task.Run(() => throw new Exception("Invalid opcode")),
        };

        await operation;
    }

    private long GetComboOperand(int operand) => operand switch
    {
        0 => 0,
        1 => 1,
        2 => 2,
        3 => 3,
        4 => RegisterA,
        5 => RegisterB,
        6 => RegisterC,
        _ => throw new Exception("Invalid operand")
    };

    // The adv instruction (opcode 0) performs division. The numerator is the value in the A register.
    // The denominator is found by raising 2 to the power of the instruction's combo operand.
    // (So, an operand of 2 would divide A by 4 (2^2); an operand of 5 would divide A by 2^B.)
    // The result of the division operation is truncated to an integer and then written to the A register.
    private async Task Adv(int operand)
    {
        RegisterA = (long)(RegisterA / Math.Pow(2, GetComboOperand(operand)));
        InstructionPointer += 2;
    }

    // The bxl instruction (opcode 1) calculates the bitwise XOR of register B and the instruction's literal operand,
    // then stores the result in register B.
    private async Task Bxl(int operand)
    {
        RegisterB = RegisterB ^ operand;
        InstructionPointer += 2;
    }

    // The bst instruction (opcode 2) calculates the value of its combo operand modulo 8 (thereby keeping only its
    // lowest 3 bits), then writes that value to the B register.
    private async Task Bst(int operand)
    {
        RegisterB = GetComboOperand(operand) % 8;
    }

    // The jnz instruction (opcode 3) does nothing if the A register is 0. However, if the A register is not zero,
    // it jumps by setting the instruction pointer to the value of its literal operand; if this instruction jumps,
    // the instruction pointer is not increased by 2 after this instruction.
    private async Task Jnz(int operand)
    {
        if (RegisterA != 0)
        {
            InstructionPointer = operand;
        }
        else
        {
            InstructionPointer += 2;
        }
    }

    // The bxc instruction (opcode 4) calculates the bitwise XOR of register B and register C, then stores the
    // result in register B. (For legacy reasons, this instruction reads an operand but ignores it.)
    private async Task Bxc(int operand)
    {
        RegisterB = RegisterB ^ RegisterC;
    }

    // The out instruction (opcode 5) calculates the value of its combo operand modulo 8, then outputs that value.
    // (If a program outputs multiple values, they are separated by commas.)
    private async Task Out(int operand)
    {
        AddOutput($"{GetComboOperand(operand) % 8}");
    }

    // The bdv instruction (opcode 6) works exactly like the adv instruction except that the result is stored
    // in the B register. (The numerator is still read from the A register.)
    private async Task Bdv(int operand)
    {

    }

    // The cdv instruction (opcode 7) works exactly like the adv instruction except that the result is stored
    // in the C register. (The numerator is still read from the A register.)
    private async Task Cdv(int operand)
    {

    }

    private void AddOutput(string newOutput)
    {
        ProgramOutput = string.Join(", ", ProgramOutput, newOutput);
    }
}
